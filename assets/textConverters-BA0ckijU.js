const u=async e=>{const s=await e.text();try{const t=JSON.parse(s),a=Array.isArray(t)?t:[t];if(a.length===0)return new Blob([""],{type:"text/csv"});const o=Object.keys(a[0]),c=[o.join(","),...a.map(r=>o.map(n=>{const l=r[n];return typeof l=="string"?`"${l}"`:l}).join(","))].join(`
`);return new Blob([c],{type:"text/csv"})}catch{throw new Error("Failed to convert JSON to CSV. Please ensure your JSON file is valid and properly formatted.")}},h=async e=>{const t=(await e.text()).split(`
`).filter(c=>c.trim());if(t.length===0)return new Blob(["[]"],{type:"application/json"});const a=t[0].split(",").map(c=>c.trim().replace(/^"|"$/g,"")),o=t.slice(1).map(c=>{const r=c.split(",").map(n=>n.trim().replace(/^"|"$/g,""));return a.reduce((n,l,p)=>(n[l]=r[p],n),{})});return new Blob([JSON.stringify(o,null,2)],{type:"application/json"})},w=async e=>{const s=await e.text();try{const t=JSON.parse(s),a=(o,c="root")=>{let r=`<${c}>`;if(typeof o=="object"&&o!==null)for(const n in o){const l=o[n];typeof l=="object"?r+=a(l,n):r+=`<${n}>${String(l)}</${n}>`}return r+=`</${c}>`,r};return new Blob([`<?xml version="1.0" encoding="UTF-8"?>
`+a(t)],{type:"application/xml"})}catch{throw new Error("Failed to convert JSON to XML. Please ensure your JSON file is valid and properly formatted.")}},f=async e=>{const s=await e.text();try{const t=JSON.parse(s);return new Blob([JSON.stringify(t,null,2)],{type:"text/plain"})}catch{return new Blob([s],{type:"text/plain"})}},g=async e=>{const s=await e.text();try{return JSON.parse(s),new Blob([s],{type:"application/json"})}catch{return new Blob([JSON.stringify({text:s})],{type:"application/json"})}},d=async e=>{const s=await e.text(),t=s.split(`
`).map(o=>o.trim()).filter(o=>o);if(t.length===0)return new Blob([s],{type:"text/csv"});const a=t.map(o=>`"${o.replace(/"/g,'""')}"`).join(`
`);return new Blob([a],{type:"text/csv"})},b=async e=>{const t=`<root><text><![CDATA[${await e.text()}]]></text></root>`;return new Blob([t],{type:"text/xml"})},v=async e=>{const s=await e.text(),a=new DOMParser().parseFromString(s,"text/xml"),o=r=>{const n={};if(r.nodeType===1){const p=r;if(p.attributes.length>0){n["@attributes"]={};for(let x=0;x<p.attributes.length;x++){const i=p.attributes.item(x);i&&(n["@attributes"][i.nodeName]=i.nodeValue)}}}else if(r.nodeType===3)return r.nodeValue||"";if(r.hasChildNodes())for(let p=0;p<r.childNodes.length;p++){const x=r.childNodes.item?r.childNodes.item(p):r.childNodes[p];if(x){const i=x.nodeName,y=n[i],m=o(x);typeof m=="string"?y===void 0?n[i]=m:(Array.isArray(y)||(n[i]=[y]),n[i].push(m)):y===void 0?n[i]=m:(Array.isArray(y)||(n[i]=[y]),n[i].push(m))}}const l=Object.keys(n);return l.length===1&&l[0]==="#text"?n["#text"]:n},c=o(a.documentElement);return new Blob([JSON.stringify(c,null,2)],{type:"application/json"})},T=async e=>{const t=(await e.text()).replace(/<[^>]*>/g,"").trim();return new Blob([t],{type:"text/plain"})},$=async e=>{const t=`<html><body><pre>${await e.text()}</pre></body></html>`;return new Blob([t],{type:"text/html"})},N=async e=>{const t=(await e.text()).replace(/,/g,"	");return new Blob([t],{type:"text/tab-separated-values"})},j=async e=>{const t=(await e.text()).replace(/\t/g,",");return new Blob([t],{type:"text/csv"})},B=async e=>{let t=(await e.text()).replace(/^### (.*$)/gim,"<h3>$1</h3>").replace(/^## (.*$)/gim,"<h2>$1</h2>").replace(/^# (.*$)/gim,"<h1>$1</h1>").replace(/\*\*(.*)\*\*/gim,"<strong>$1</strong>").replace(/\*(.*)\*/gim,"<em>$1</em>").replace(/`([^`]+)`/gim,"<code>$1</code>").replace(/\n\n/gim,"</p><p>").replace(/\n/gim,"<br>");return t=`<html><body><p>${t}</p></body></html>`,new Blob([t],{type:"text/html"})},J={jsonToCsv:u,csvToJson:h,jsonToXml:w,jsonToTxt:f,txtToJson:g,txtToCsv:d,txtToXml:b,xmlToJson:v,htmlToTxt:T,txtToHtml:$,csvToTsv:N,tsvToCsv:j,mdToHtml:B};export{J as textConverters};
